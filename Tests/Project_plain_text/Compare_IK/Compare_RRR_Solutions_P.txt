PROGRAM Compare_RRR_Solutions
VAR CONSTANT
    PI : LREAL := 3.14159265358979323846;
    
    // RRR Link lengths
    RRR_link_a : LREAL := 300.0; // mm
    RRR_link_b : LREAL := 250.0; // mm
    RRR_link_c : LREAL := 100.0; // mm (from wrist to TCP for analytical solver)
END_VAR
VAR
    // --- Inputs for Analytical RRR Solver ---
    analytic_Px_target    : LREAL := 400.0;
    analytic_Py_target    : LREAL := 150.0;
    analytic_Phi_target   : LREAL := PI / 4.0; // radians
    analytic_Elbow_Up     : BOOL  := TRUE;

    // --- Instance and Outputs for Analytical RRR Solver ---
    fbAnalyticRRR_IK      : FB_RRR_Inverse_Kinematics;
    q1_analytic           : LREAL;
    q2_analytic           : LREAL;
    q3_analytic           : LREAL;
    analytic_is_reachable : BOOL;

    // --- Inputs for Numerical getInvKinematics_Body Solver ---
    // M: Initial End-Effector Pose (when all thetalist = 0)
    M_numerical: ARRAY[1..4, 1..4] OF REAL := 
        [[1,0,0, (RRR_link_a + RRR_link_b + RRR_link_c)], // Col 4: x
         [0,1,0,0],                                     // Col 4: y
         [0,0,1,0],                                     // Col 4: z
         [0,0,0,1]];

    // T: Target End-Effector Pose
    T_numerical: ARRAY[1..4, 1..4] OF REAL;
    
    // Blist: Body Screw Axes (6xN_JOINTS), N_JOINTS = 3 for RRR
    Blist_numerical: ARRAY[1..6, 1..GVL_Compare.MAX_JOINTS] OF REAL;
        // GVL_Compare.MAX_JOINTS should be 3

    // thetalist0: Initial guess for joint angles
    thetalist0_numerical: ARRAY[1..GVL_Compare.MAX_JOINTS] OF REAL := [0.0, 0.0, 0.0];

    // Tolerances
    eomg_numerical : REAL := 0.001; // rad
    ev_numerical   : REAL := 0.001; // mm

    // --- Instance and Outputs for Numerical Solver ---
    fbNumericalIK         : getInvKinematics_Body;
    thetalist_numerical   : ARRAY[1..GVL_Compare.MAX_JOINTS] OF REAL;
    numerical_success     : BOOL;
    numerical_Error_msg   : STRING;
    
    // Helper variables for T matrix calculation
    cos_phi : REAL;
    sin_phi : REAL;
    
    // Trigger for execution (set to TRUE once to run)
    bExecuteComparison : BOOL := TRUE; 
END_VAR

// --- Program Body ---
IF bExecuteComparison THEN
    // 1. Initialize T_numerical (Target Pose Matrix)
    cos_phi := TO_REAL(COS(analytic_Phi_target));
    sin_phi := TO_REAL(SIN(analytic_Phi_target));
    
    T_numerical[1,1] := cos_phi; T_numerical[1,2] := -sin_phi; T_numerical[1,3] := 0; T_numerical[1,4] := TO_REAL(analytic_Px_target);
    T_numerical[2,1] := sin_phi; T_numerical[2,2] :=  cos_phi; T_numerical[2,3] := 0; T_numerical[2,4] := TO_REAL(analytic_Py_target);
    T_numerical[3,1] := 0;       T_numerical[3,2] := 0;        T_numerical[3,3] := 1; T_numerical[3,4] := 0;
    T_numerical[4,1] := 0;       T_numerical[4,2] := 0;        T_numerical[4,3] := 0; T_numerical[4,4] := 1;

    // 2. Initialize Blist_numerical (Body Screw Axes)
    // Blist[:,1] = [0,0,1, 0, La+Lb+Lc, 0] (Lc here is the third link for RRR_link_c)
    // Blist[:,2] = [0,0,1, 0, Lb+Lc,    0]
    // Blist[:,3] = [0,0,1, 0, Lc,       0]
    Blist_numerical[1,1]:=0; Blist_numerical[1,2]:=0; Blist_numerical[1,3]:=0;
    Blist_numerical[2,1]:=0; Blist_numerical[2,2]:=0; Blist_numerical[2,3]:=0;
    Blist_numerical[3,1]:=1; Blist_numerical[3,2]:=1; Blist_numerical[3,3]:=1;
    Blist_numerical[4,1]:=0; Blist_numerical[4,2]:=0; Blist_numerical[4,3]:=0;
    Blist_numerical[5,1]:=TO_REAL(RRR_link_a + RRR_link_b + RRR_link_c); 
    Blist_numerical[5,2]:=TO_REAL(RRR_link_b + RRR_link_c); 
    Blist_numerical[5,3]:=TO_REAL(RRR_link_c);
    Blist_numerical[6,1]:=0; Blist_numerical[6,2]:=0; Blist_numerical[6,3]:=0;

    // --- Call Analytical RRR IK Solver ---
    fbAnalyticRRR_IK(
        Px_target    := analytic_Px_target,
        Py_target    := analytic_Py_target,
        Phi_target   := analytic_Phi_target,
        link_a       := RRR_link_a,
        link_b       := RRR_link_b,
        link_c       := RRR_link_c, // This is the 3rd link for the RRR analytical model
        Elbow_Up     := analytic_Elbow_Up,
        q1           => q1_analytic,
        q2           => q2_analytic,
        q3           => q3_analytic,
        is_reachable => analytic_is_reachable
    );

    // --- Call Numerical IK Solver ---
    // Note: getInvKinematics_Body uses REAL, analytical uses LREAL. Conversions applied for inputs.
    fbNumericalIK(
        M          := M_numerical,
        T          := T_numerical,
        eomg       := eomg_numerical,
        ev         := ev_numerical,
        Blist      := Blist_numerical,
        thetalist0 := thetalist0_numerical,
        thetalist  => thetalist_numerical, // Output
        success    => numerical_success,
        Error      => numerical_Error_msg
    );
    
    bExecuteComparison := FALSE; // Run once
END_IF

// Results are now in:
// q1_analytic, q2_analytic, q3_analytic, analytic_is_reachable
// thetalist_numerical[1], thetalist_numerical[2], thetalist_numerical[3], numerical_success, numerical_Error_msg
// You can view these variables in the CODESYS debugger to compare them.

END_PROGRAM 