(*
--------------------------------------------------------------------------------
Function Block: FB_RRR_Inverse_Kinematics
Description: Calculates the inverse kinematics for a 3-link planar RRR manipulator.
             Given a target position (Px, Py) and orientation (Phi) for the end-effector,
             and link lengths (link_a, link_b, link_c), it computes the joint angles (q1, q2, q3).
--------------------------------------------------------------------------------
*)
FUNCTION_BLOCK FB_RRR_Inverse_Kinematics
VAR_INPUT
    Px_target    : LREAL := 0.0; // Target X position of the end-effector
    Py_target    : LREAL := 0.0; // Target Y position of the end-effector
    Phi_target   : LREAL := 0.0; // Target orientation of the end-effector (radians, relative to X-axis of base frame)
    link_a       : LREAL := 1.0; // Length of the first link (dimension 'a')
    link_b       : LREAL := 1.0; // Length of the second link (dimension 'b')
    link_c       : LREAL := 1.0; // Length of the third link, from wrist to TCP (dimension 'c')
    Elbow_Up     : BOOL  := TRUE; // Selects elbow up (TRUE) or elbow down (FALSE) solution for the wrist positioning
END_VAR
VAR_OUTPUT
    q1           : LREAL := 0.0; // Joint angle 1 (radians)
    q2           : LREAL := 0.0; // Joint angle 2 (radians)
    q3           : LREAL := 0.0; // Joint angle 3 (radians)
    is_reachable : BOOL  := FALSE;// Flag indicating if the target is reachable
END_VAR
VAR
    Px_wrist     : LREAL;         // X-coordinate of the wrist (end of link_b)
    Py_wrist     : LREAL;         // Y-coordinate of the wrist (end of link_b)
    dist_sq_wrist: LREAL;         // Squared distance from origin to wrist
    cos_q2_num   : LREAL;         // Numerator for calculating cos(q2)
    cos_q2_den   : LREAL;         // Denominator for calculating cos(q2)
    cos_q2_val   : LREAL;         // Value of cos(q2)
    sin_q2_val   : LREAL;         // Value of sin(q2)
    k1_for_q1    : LREAL;         // Intermediate variable for q1 calculation: link_a + link_b * cos(q2)
    k2_for_q1    : LREAL;         // Intermediate variable for q1 calculation: link_b * sin(q2)
    sqrt_arg     : LREAL;         // Argument for SQRT function, checked for non-negativity
END_VAR

// --- Function Block Body ---

// 1. Calculate the position of the wrist (Px_wrist, Py_wrist)
// The wrist is the point where link_b and link_c connect.
// To reach (Px_target, Py_target) with link_c at orientation Phi_target,
// the wrist must be at:
Px_wrist := Px_target - link_c * COS(Phi_target);
Py_wrist := Py_target - link_c * SIN(Phi_target);

// 2. Solve inverse kinematics for the first two links (link_a, link_b) to reach (Px_wrist, Py_wrist)
// This is a standard 2R planar robot problem.
dist_sq_wrist := Px_wrist * Px_wrist + Py_wrist * Py_wrist;

// Check for division by zero if link_a or link_b is zero.
// Also handles cases where the 2-link arm formula is undefined.
IF link_a <= 0.0 OR link_b <= 0.0 THEN // Link lengths must be positive
    is_reachable := FALSE;
    q1 := 0.0;
    q2 := 0.0;
    q3 := 0.0;
    RETURN; // Exit calculation
END_IF

cos_q2_den := 2.0 * link_a * link_b;
// Denominator should not be zero if link_a and link_b are positive.
// This check is mostly for safety if inputs were non-positive.
IF cos_q2_den = 0.0 THEN
    is_reachable := FALSE;
    q1 := 0.0;
    q2 := 0.0;
    q3 := 0.0;
    RETURN;
END_IF

cos_q2_num := dist_sq_wrist - link_a * link_a - link_b * link_b;
cos_q2_val := cos_q2_num / cos_q2_den;

// Check reachability: -1 <= cos_q2_val <= 1.
// A small tolerance (e.g., 1.0E-6 or 0.000001) is used for floating point comparisons.
IF (cos_q2_val > 1.000001) OR (cos_q2_val < -1.000001) THEN
    is_reachable := FALSE;
    q1 := 0.0;
    q2 := 0.0;
    q3 := 0.0;
ELSE
    is_reachable := TRUE;
    
    // Clamp cos_q2_val to [-1, 1] to prevent domain errors with SQRT due to precision issues.
    IF cos_q2_val > 1.0 THEN
        cos_q2_val := 1.0;
    ELSIF cos_q2_val < -1.0 THEN
        cos_q2_val := -1.0;
    END_IF
    
    // Calculate sin(q2). Argument for SQRT should be non-negative due to clamping.
    sqrt_arg := 1.0 - cos_q2_val * cos_q2_val;
    IF sqrt_arg < 0.0 THEN // Safety check, should not happen if clamped
        sqrt_arg := 0.0;
    END_IF

    IF Elbow_Up THEN
        sin_q2_val := SQRT(sqrt_arg); // Elbow up solution
    ELSE
        sin_q2_val := -SQRT(sqrt_arg); // Elbow down solution
    END_IF

    q2 := BASIC.ATAN2(sin_q2_val, cos_q2_val);

    // 3. Calculate q1
    // Using the formula: q1 = ATAN2(Py_wrist, Px_wrist) - ATAN2(link_b * sin(q2), link_a + link_b * cos(q2))
    k1_for_q1 := link_a + link_b * cos_q2_val; // This is link_a + link_b * COS(q2)
    k2_for_q1 := link_b * sin_q2_val;       // This is link_b * SIN(q2)
    
    q1 := BASIC.ATAN2(Py_wrist, Px_wrist) - BASIC.ATAN2(k2_for_q1, k1_for_q1);

    // 4. Calculate q3
    // The overall orientation Phi_target is the sum of the joint angles: Phi_target = q1 + q2 + q3
    // Therefore, q3 = Phi_target - q1 - q2
    q3 := Phi_target - q1 - q2;

    // Optional: Normalize angles (e.g., q1, q2, q3) to a specific range like [-PI, PI] or [0, 2*PI).
    // ATAN2 typically returns values in (-PI, PI]. q3 might need normalization depending on requirements.
    // Example normalization for q3 to (-PI, PI]:
    // WHILE q3 > PI DO q3 := q3 - 2.0 * PI; END_WHILE;
    // WHILE q3 <= -PI DO q3 := q3 + 2.0 * PI; END_WHILE;
    // For this simple example, we leave them as calculated.
END_IF

END_FUNCTION_BLOCK


(*
--------------------------------------------------------------------------------
Program: Main_RRR_IK_Example
Description: Demonstrates the usage of the FB_RRR_Inverse_Kinematics Function Block.
             Sets target parameters and retrieves the calculated joint angles.
--------------------------------------------------------------------------------
*)
PROGRAM Main_RRR_IK_Example
VAR CONSTANT
    PI : LREAL := 3.14159265358979323846; // Definition of PI
END_VAR
VAR
    // Instance of the Inverse Kinematics Function Block
    ik_calculator : FB_RRR_Inverse_Kinematics;

    // Robot parameters (link lengths a, b, c)
    robot_link_a : LREAL := 300.0; // e.g., in mm
    robot_link_b : LREAL := 250.0; // e.g., in mm
    robot_link_c : LREAL := 100.0; // e.g., in mm

    // Target for the end-effector
    target_pos_x : LREAL := 400.0; 
    target_pos_y : LREAL := 150.0; 
    target_orientation_phi : LREAL := PI / 4.0; // Target orientation: 45 degrees (PI/4 radians)
                                               // Assumes PI is defined (e.g. via a library or CONSTANT PI : LREAL := 3.1415926535;)
    
    // Choice for elbow configuration for the 2-link sub-problem
    choose_elbow_up_solution : BOOL := TRUE;

    // Outputs from the IK calculation
    calculated_q1 : LREAL;
    calculated_q2 : LREAL;
    calculated_q3 : LREAL;
    target_is_reachable : BOOL;
    
    // Example trigger for calculation (optional, as FB body executes based on inputs)
    // bExecuteIK : BOOL := TRUE; 
END_VAR

// --- Program Body ---
// The program body is executed cyclically in CODESYS.
// We provide inputs to the Function Block instance. It will then calculate the outputs.

// IF bExecuteIK THEN // For a one-shot calculation, or remove for continuous calculation
    ik_calculator(
        Px_target    := target_pos_x,
        Py_target    := target_pos_y,
        Phi_target   := target_orientation_phi,
        link_a       := robot_link_a,
        link_b       := robot_link_b,
        link_c       := robot_link_c,
        Elbow_Up     := choose_elbow_up_solution
    );

    // Retrieve the results from the Function Block instance
    calculated_q1 := ik_calculator.q1;
    calculated_q2 := ik_calculator.q2;
    calculated_q3 := ik_calculator.q3;
    target_is_reachable := ik_calculator.is_reachable;

    // bExecuteIK := FALSE; // Uncomment to run calculation once
// END_IF;

// At this point, 'calculated_q1', 'calculated_q2', 'calculated_q3', and 'target_is_reachable'
// hold the results of the inverse kinematics calculation.
// You can use these values, for example, to:
// - Display them on an HMI.
// - Send them as setpoints to motor controllers.
// - Use them in a simulation.

// Example of how you might check reachability and use the angles:
(*
IF target_is_reachable THEN
    // Robot can reach the target. Use calculated_q1, calculated_q2, calculated_q3.
    // Example: Log message (actual logging depends on CODESYS target/libraries)
    // LogAddMsg(msgType := 1, 글로벌.GVL_String := CONCAT('IK solution: q1=', LREAL_TO_STRING(calculated_q1)));
    // LogAddMsg(msgType := 1, 글로벌.GVL_String := CONCAT('             q2=', LREAL_TO_STRING(calculated_q2)));
    // LogAddMsg(msgType := 1, 글로벌.GVL_String := CONCAT('             q3=', LREAL_TO_STRING(calculated_q3)));
ELSE
    // Target is not reachable with the current robot dimensions and target.
    // LogAddMsg(msgType := 2, 글로벌.GVL_String := 'Target is not reachable.');
END_IF
*)

END_PROGRAM
