// Function Block to apply row permutations defined by P_indices to matrix A
FUNCTION_BLOCK ApplyPermutation
VAR_INPUT
	nSize : DINT; // The actual size of the square matrix to permute (up to MAX_INV_SIZE)
	// Pivot indices (1-based permutation vector from LuDecomposition)
	P_indices : ARRAY [1..GVL.MAX_INV_SIZE] OF DINT;
	// Input matrix (fixed size internally)
	A : ARRAY [1..GVL.MAX_INV_SIZE, 1..GVL.MAX_INV_SIZE] OF REAL;
END_VAR
VAR_OUTPUT
	// Output permuted matrix (P*A)
	PA : ARRAY [1..GVL.MAX_INV_SIZE, 1..GVL.MAX_INV_SIZE] OF REAL;
END_VAR
VAR
	i : DINT; // Row index for PA
	j : DINT; // Column index for PA
	p_idx : DINT; // Original row index from P_indices
END_VAR

// Initialize output matrix to zeros for safety (up to nSize)
FOR i := 1 TO nSize DO
    FOR j := 1 TO nSize DO
        PA[i, j] := 0.0;
    END_FOR
END_FOR

// Apply permutation
// For each row `i` in the target permuted matrix `PA`,
// find the corresponding original row index `p_idx` from `P_indices`,
// and copy the entire row `A[p_idx, *]` to `PA[i, *]`.
IF nSize > 0 AND nSize <= GVL.MAX_INV_SIZE THEN
    FOR i := 1 TO nSize DO
        // Get the original row index that should move to row 'i'
        p_idx := P_indices[i];
        
        // Check bounds for safety, although P_indices should be valid if from LU decomp
        IF p_idx >= 1 AND p_idx <= nSize THEN 
            // Copy the corresponding original row to the target row
            FOR j := 1 TO nSize DO
                PA[i, j] := A[p_idx, j];
            END_FOR
        ELSE
            // Handle potential invalid index in P_indices (optional error handling)
            // For now, just skip or zero out the row
             FOR j := 1 TO nSize DO
                PA[i, j] := 0.0; // Or set an error flag
            END_FOR
        END_IF
    END_FOR
END_IF 